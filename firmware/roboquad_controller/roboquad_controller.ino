// Simple Arduino controller for a 2007 Roboquad from Wowee Robotics
// Assumes 39.2 kHz carrier frequency for IR is being generated by a 555 timer,
//   and that IR_BURST_ENABLE_PIN can be used to turn the timer, and thus the 
//   IR LED, on and off.

// Information of IR control protocol obtained from:
//   http://www.markcra.com/robot/ir_codes_quad.php

// Movement commands
#define STOP            0x600
#define FORWARD         0x601
#define BACKWARD        0x602
#define LEFT            0x603
#define RIGHT           0x604

#define TOP_LEFT        0x605
#define TOP_RIGHT       0x606
#define BOTTOM_LEFT     0x607
#define BOTTOM_RIGHT    0x608

#define ROT_CW          0x609
#define ROT_CCW         0x60A
#define AUTONOMY_MODE   0x610

// Personality settings. Only valid if a shift level is applied.
#define ACTIVITY_LEVEL  0x611
#define AGRESSION_LEVEL 0x612
#define AWARENESS_LEVEL 0x613

#define PROGRAM         0x614
#define PROGRAM_PLAY    0x615

#define DEMO            0x616

// Commands are shifted by adding the appropriate offset to the base command code.
// To look at what all the commands do, read the manual:
//   http://www.robotsandcomputers.com/robots/manuals/Roboquad.pdf
#define SHIFT_1 0x000
#define SHIFT_2 0x020
#define SHIFT_3 0x040
#define SHIFT_4 0x080


const uint32_t MODULATION_TIMESTEP_US = 833; // Data sent to robot at 1200 baud.
const uint16_t IR_BURST_ENABLE_PIN = 8;

void transmitCommand(uint16_t command) {
  // Start by sending start signal
  // Start indicated by IR going low for 8 modulation cycles
  //PORTH &= ~IR_BURST_ENABLE_PIN; // Pull enable pin low.
  //PORTH |= IR_BURST_ENABLE_PIN;
  digitalWrite(IR_BURST_ENABLE_PIN, HIGH);
  delayMicroseconds(MODULATION_TIMESTEP_US*8);

  // Now transmit the command, starting with the MSB
  for(int i=0; i<12; ++i) {
    uint8_t command_bit = (command >> (11 - i) ) & 0x001;
    
    if(command_bit) {
      // To transmit a one, pull signal low for four cycles then high for one cycle
      digitalWrite(IR_BURST_ENABLE_PIN, LOW);
      delayMicroseconds(MODULATION_TIMESTEP_US*4);
      digitalWrite(IR_BURST_ENABLE_PIN, HIGH);
      delayMicroseconds(MODULATION_TIMESTEP_US);
    }
    else {
      // To transmit a zero, pull signal low for one cycle then high for one cycle
      digitalWrite(IR_BURST_ENABLE_PIN, LOW);
      delayMicroseconds(MODULATION_TIMESTEP_US);
      digitalWrite(IR_BURST_ENABLE_PIN, HIGH);
      delayMicroseconds(MODULATION_TIMESTEP_US);            
    }
  }
  digitalWrite(IR_BURST_ENABLE_PIN, LOW);
  delay(250); // Don't allow commands to be sent too frequently.
}

void setup() {
  Serial.begin(57600); // Receive robot commands from the PC 
  // Clear garbage in serial buffer
  while(!Serial) {
    while(Serial.available() > 0) {
      Serial.read();
    }
  }
  
  pinMode(IR_BURST_ENABLE_PIN, OUTPUT);
  digitalWrite(IR_BURST_ENABLE_PIN, LOW); // IR off when channel is idle.
}

void loop() {
  // Check if we have received a command
  if(Serial.available()) {
    delay(100);
    uint8_t buff_size = 10;
    char buff[buff_size];
    uint8_t buff_idx = 0;

    // Read in command. Format is two ascii character to signify command followed 
    //   by number indicating shift level
    while((Serial.available() > 0) && (buff_idx < buff_size)) {
      buff[buff_idx] = Serial.read();
      buff_idx++;
    }
    
    // Parse command from buffer
    uint16_t command = 0x0000;
    if((buff[0] == 's') && (buff[1] == 't')) command = STOP;
    else if((buff[0] == 'f') && (buff[1] == 'w')) command = FORWARD;
    else if((buff[0] == 'b') && (buff[1] == 'w')) command = BACKWARD;
    else if((buff[0] == 'l') && (buff[1] == 'f')) command = LEFT;
    else if((buff[0] == 'r') && (buff[1] == 't')) command = RIGHT;

    else if((buff[0] == 't') && (buff[1] == 'l')) command = TOP_LEFT;
    else if((buff[0] == 't') && (buff[1] == 'r')) command = TOP_RIGHT;
    else if((buff[0] == 'b') && (buff[1] == 'l')) command = BOTTOM_LEFT;
    else if((buff[0] == 'b') && (buff[1] == 'r')) command = BOTTOM_RIGHT;
    else if((buff[0] == 'c') && (buff[1] == 'w')) command = ROT_CW;
    else if((buff[0] == 'c') && (buff[1] == 'c')) command = ROT_CCW;
    else if((buff[0] == 'a') && (buff[1] == 'u')) command = AUTONOMY_MODE;
    
    else if((buff[0] == 'a') && (buff[1] == 'c')) command = ACTIVITY_LEVEL;
    else if((buff[0] == 'a') && (buff[1] == 'g')) command = AGRESSION_LEVEL;
    else if((buff[0] == 'a') && (buff[1] == 'w')) command = AWARENESS_LEVEL;

    else if((buff[0] == 'p') && (buff[1] == 'g')) command = PROGRAM;
    else if((buff[0] == 'p') && (buff[1] == 'p')) command = PROGRAM_PLAY;
    
    else if((buff[0] == 'd') && (buff[1] == 'm')) command = DEMO;

    // Parse shift from buffer
    uint16_t shift = 0x0000;
    if(buff[2] == '1') shift = SHIFT_1;
    else if(buff[2] == '2') shift = SHIFT_2;
    else if(buff[2] == '3') shift = SHIFT_3;
    else if(buff[2] == '4') shift = SHIFT_4;

    // Shift command and transmit to robot
    command |= shift;
    if(command) {
      transmitCommand(command);
    }
  }
}
